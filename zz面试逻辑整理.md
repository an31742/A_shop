# 我给大家做个简单整理 大家沿着这个思路 自己去阻止语言
- 自己组织自己的语言 不要互相抄或者模仿 
- 很容易面试到同一家公司 
- 结果是大家都玩完了

# 加入购物车
1. 购物车其实是一个数组, 对象数组, 每个对象 就是描述每个商品
2. 点击按钮, 是想把该商品加入到购物车里面
3. 加入之前,我们要做个判断, 判断该商品之前是否添加过
4. 如果之前没有添加到购物车里面, 把该商品组成一个对象, 添加进去
   - 并且 商品的数量默认为 1 
   - 我们可以根据商品的id 去判断是否添加到商品里面过
   - 根据id 通过 find() 查找对应的商品 看是否存在即可
5. ........有................, 把该商品的数量 累加



# 购物车逻辑 
0. 开始从本地获取购物车, 遍历展示页面,  计算结算和合计

1. 购物车分为几块功能  
  1.1 修改数量(+-)
  1.2 点击多选框选择是否支付该商品
  1.3 点击全选
  1.4 统计结算和合计
2. 如果他们觉得功能不全, 没有淘宝京东这么全, 我们可以说这个第一个版本,
   产品那边正在迭代, 那边更新好了 我们会继续同步  

3. 点击 + - 代码逻辑如何完成的 ? 考察你的代码
  3.1 给+和- 都注册同一个事件, 因为我们觉得只是传递的数据不一样而已
  3.2 注册的事件 bindtap='addCount' 
  3.3 传递的参数分别为 1 和 -1 , data-count='{{ 1}}' / '{{ -1 }}'
  3.4 传递的参数是可以了 但是缺少id 不然我不知道点击的是哪个
  3.5 所以 我们后面有传递了参数  id  data-id='{{ item.goods_id }}'
  3.6 这样, 我们就得到了 count 和 id
  3.7 我们根据 id 从购物车里面找到对应的商品, 把 数量 += count 即可
  3.8 有个临界情况, 就是说如果数量为1, 依然点击 -1 , 就是要删除该商品,   
     goods.goods_num === 1 && count == -1 , 
  3.9 来个弹框, 删除该商品 (我们是通过过滤删除的) 
  3.10 重新计算 结算的个数 和总价格  

4. 点击该商品的多选框
  4.1 点击该商品的多选框 其实就想改变商品的选中状态
  4.2 给 checkbox-group 通过 bindchange 绑定一个事件, 监听改变
  4.3 还要传递一个id, 以为我们不知道监听的是哪个 data-id='{{ goods_id }}'
  4.4 拿到id, 找到对应的商品, 拿到商品的 选中属性 取反
      goods.isChecked = !goods.isChecked
  4.5 重新计算 结算的个数 和总价格 

5. 计算结算和合计
 5.1 我们单独封装一个方法 来计算结算和合计
 5.2 遍历我们的购物车, 通过判断 来遍历 `选中状态`的商品来计算合计和总计算
 5.3 totalCunt += v.goods_num    数量累加
 5.4 totalPrice += v.goods_num * v.goods_price  数量*单价 累加

6. 全选功能
 - 下 => 上
  - 点击全选, 遍历所有的商品,让商品的选中状态取反
   
 - 上 => 下
    - 在 计算结算和合计的方法里面判断
    - 遍历 购物车的时候, 如果有一个以上出现了 选中状态为false的商品 , 全选值就为false
    - 处理 数量为0 的情况, 如果购物车商品为0, 全选的值肯定是false

- 问 :还有呢?? 然后呢?? 没有了吗???
- 大家要解答 : 先总后分
- 要以一个很简单明了的话概述你的答案, 开始不要说太多废话, 
- 他想知道更多细节 , 他去问, 

# 获取地址授权
1. 开始点击按钮, 获取收货地址, 弹框, 点击确定就可以了,就能够正常获取了
2. 但是我发现了有些小程序他们没有处理取消这个情况, 我就发现了, 我们就把取消这块也处理了
3. 以为你获取收货地址也是权限问题, 所以我就开始先获取授权情况
4. 通过 小程序的官方 api wx.getSetting() => 它(res)的 authSettting,
5. 又因为我们获取的是地址
    打印  res.authSetting['scope.addres']
6. `这个结果通过不断的调试`, 我们会得到三种结果
  - `undefined`  => 从来没有授权同意过 也没有拒绝过
  - `true` => 授权同意过
  - `false` => 授权拒绝过
7. 我们通过一个判断, 如果false,的话,我们再通过 官方api wx.openSetting()
  调用设置页面 手动开启授权功能, 
8. 如果是undefined和true,我们就通过官方api wx.chooseAddress() 获取地址     


# 登录
- 先总后分
- 总
  - 1. 我们登录这块功能, 是利用了后台提供给我们的一个接口来完成的
  - 2. 我们主要就是把 code 和 用户信息获取的四个参数 传递给后台, 
       后台就返回给我们一个token 即可
- 分 
  - 那你知道这个token是怎么回来的呢??  (登录的流程时序)
  - https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html
1. 这个流程是通过三方完成的 小程序 、后台、微信接口服务
2. 小程序首先通过 wx.request 把  wx.login()得到的code 发给后台 
3. 后台把code传递给微信接口服务,顺序传递的还有 appId(id 身份证) 和 appSecret(秘钥)
4. 微信接口服务 接收到了三个参数, 并且返回 session_key(秘钥) 和 openid(用户id), 给后台
5. 后台根据 session_key(秘钥) 和 openid(用户id) 生成一个 自定义态, 也就是我们口中常说的token令牌, 来保持登录状态的
6. 后台把token 返回给小程序, 小程序拿到token 保存到本地
7. 以后发送业务请求, 都要携带这个token, 
8. 如果某一天真的有退出功能, 
  - 小程序的token 要删除, 还要发送一个请求给后台,我们退出了, 后台把他们那存的token移除掉



# 支付
- 准备工作
 一定要申请一个企业微信(前端), 绑定一个银行卡(后台)

- 1. 创建订单一个订单 
  - 参数 :token  + 总价格+地址+商品数组
  - 结果 :order_number 订单号
- 2. 预支付
  - 参数 :token + order_number
  - 结果 : pay对象
- 3. 支付
  - 通过 官方api - wx.requestPayment() 来发起支付
  - 参数 : pay对象
  - 结果 => 模拟器上显示一个收款码

- 4. 查看支付状态
 - 参数 : order_number
 - 结果 :告诉是否支付成功

- 5. 收尾
  - 5.1 把本地选中商品(要支付的商品 删除掉)
  - 5.2 提示支付成功
  - 5.3 跳转到订单页面
